import numpy as np
import matplotlib.pyplot as plt

def row_normalize(M):
    """Make each row of M sum to 1 (row‑stochastic)."""
    return M / (M.sum(axis=1, keepdims=True) + 1e-12)

def build_Ap_bidir(N, A):
    size = 5 * N
    Ap   = np.zeros((size, size))
    Ap[:N, :N] = A / 2.0
    for i in range(N):
        base = N + 4*i
        i1, i2, i3, i4 = base, base + 1, base + 2, base + 3
        print(base)
        Ap[i,   i1] = 1/12
        Ap[i,   i2] =  1/8
        Ap[i,   i3] =  1/4
        Ap[i,   i4] = 1/24

        Ap[i1, i] = 1/11       
        Ap[i2, i] =   1/2       
        Ap[i3, i] =   3/4      
        Ap[i4, i] = 1/16      

       
        Ap[i2, i1] =  1/2       
        Ap[i3, i1] =  1/4       
        Ap[i4, i1] = 15/16     

        Ap[i1, i2] =  3/22    
        Ap[i1, i3] =   1/11   
        Ap[i1, i4] = 15/22   

    return row_normalize(Ap)



def distributed_solve_alg4(N, Ap, x0):
    """
    Algorithm 4: compute the left‑eigenvector vL and initial xP0.
    """
    size = 5 * N
    s    = np.zeros(size)
    s[0] = 1.0


    visited = {0}
    remaining = set(range(1, N))
    while remaining:
        for j in list(remaining):
            for i in visited:
                if Ap[i, j] > 0 and Ap[j, i] > 0:
                    s[j] = s[i] * Ap[i, j] / Ap[j, i]
                    visited.add(j)
                    remaining.remove(j)
                    break
            else:
                continue
            break

    for i in range(N):
        si   = s[i]
        base = N + 4*i
        s[ base + 0 ] = (11/12)*si
        s[ base + 1 ] =   (1/4)*si
        s[ base + 2 ] =   (1/3)*si
        s[ base + 3 ] =   (2/3)*si


    Z  = s.sum()
    vL = s / Z

    xP0 = np.zeros(5*N)
    for i in range(N):
        xi    = x0[i]
        base  = N + 4*i                      
        alphas = np.ones(4)*(5*xi/4)         
   
        xP0[i] = 0.0


        for k in range(4):
            idx       = base + k
            xP0[idx]  = (Z / s[idx]) * alphas[k]
    print(Ap)
    print('This is the output Vector', xP0)

    avg     = x0.mean()
    current = vL @ xP0
    xP0    *= (avg/current)


    return vL, xP0


if __name__ == "__main__":

    N  = 3
    A  = np.array([[0, 0.5, 0.5],
                   [0.5, 0, 0.5],
                   [0.5, 0.5, 0]], dtype=float)
    
    x0 = np.array([0.5, 1/3, 0.2])
    A_norm = row_normalize(A)
    Ap     = build_Ap_bidir(N, A)
    vL, xP0 = distributed_solve_alg4(N, Ap, x0)

    # simulate
    steps = 30
    Xo = np.zeros((N,    steps+1))
    Xa = np.zeros((5*N,  steps+1))
    Xo[:,0] = x0
    Xa[:,0] = xP0
    for k in range(steps):
        Xo[:,k+1] = A_norm @ Xo[:,k]
        Xa[:,k+1] = Ap @ Xa[:,k]

    # plot
    target = x0.mean()
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8,10))

    # (a) original
    for i in range(N):
        ax1.plot(Xo[i], label=f'$x_{{{i+1}}}[k]$')
    ax1.axhline(target, color='k', lw=1, label=f'Consensus={target:.2f}')
    ax1.set_title('(a) Consensus on the 3‑cycle $G(A)$')
    ax1.set_xlabel('Step $k$'); ax1.set_ylabel('Value')
    ax1.legend(loc='upper right'); ax1.grid(True)

    # (b) augmented
    for i in range(5*N):
        if i < N:
            lbl = f'$x_{{{i+1}}}[k]$'
        else:
            agent = (i - N)//4 + 1
            aug   = (i - N)%4 + 1
            lbl   = f'$\\tilde x_{{{agent},{aug}}}[k]$'
        ax2.plot(Xa[i], label=lbl)
    ax2.axhline(target, color='k', lw=1, label=f'Consensus={target:.2f}')
    ax2.set_title('(b) Consensus on the augmented $G(A^P)$')
    ax2.set_xlabel('Step $k$'); ax2.set_ylabel('Value')
    ax2.legend(ncol=4, loc='upper right', fontsize='small'); ax2.grid(True)

    plt.tight_layout()
    plt.show()
